# vue编译优化-树结构打平
## 概念引入
在vue官方文档‘渲染机制’里有提到：
这里我们引入一个概念“区块”，内部结构是稳定的一个部分可被称之为一个区块。。。
每一个块都会追踪其所有带更新类型标记的后代节点 (不只是直接子节点)。。。
编译的结果会被打平为一个数组，仅包含所有动态的后代节点。
当这个组件需要重渲染时，只需要遍历这个打平的树而非整棵树。
这也就是我们所说的树结构打平，这大大减少了我们在虚拟 DOM 协调时需要遍历的节点数量。模板中任何的静态部分都会被高效地略过。

## 初步设计
树结构打平成数组，从递归变成遍历，这种优化的结果是显而易见的。看到这些描述后，我脑袋里就衍生出了大概得逻辑：
1. 新增一个createBlock方法，用来创建一个区块
2. createBlock方法里新增一个dynamicChildren数组，用来存储当前区块的所有动态后代节点，子区块本身也会当成动态子节点存储
3. 除了dynamicChildren数组，createBlock的其他逻辑跟createVNode基本是一致的
4. render函数生成后的虚拟节点树，还是保持了原有的树结构，只是区块节点上新增了dynamicChildren数组，用来存储当前节点的所有动态后代节点
5. 挂载阶段依然按原有逻辑递归遍历虚拟dom树，挂载完成后，dynamicChildren存储的vnode就有了el属性，指向了真实dom节点
6. 更新阶段，调用render函数生成新的虚拟节点树，但diff时就不再递归对比整个树，而是直接对比dynamicChildren数组
总结：整个工作的目的都是为了diff时的优化

同时还存在几个具体实现的问题：
1. 怎么辨别是否要用createBlock创建区块

上面的分析可以知道createBlock的关键作用在于收集dynamicChildren，也就是说得有动态子节点。
除此之外还得满足以下任一条件：
根节点、组件边界、结构型指令（v-if,v-for）
对于满足条件的在更新类型标记时，可以增加标识isblock:true,generate阶段根据isblock判断是否创建createBlock
// v-if，v-for需要更详细的考虑
含有动态子节点的元素，是否设置区块？
v-if 值为false时，是否设置区块？
v-for 元素本身设置区块还是父级设置区块？



2. dynamicChildren数组是什么时候收集的
按道理说，做了更新类型标记的元素就应该被收集到dynamicChildren数组里。最开始我想到的是可以在动态标记优化时根据PatchFlag收集dynamicChildren。

但是dynamicChildren需要收集的是vnode，在编译阶段，vnode还没有生成呢，那怎么保证引用正确的vnode？
所以说dynamicChildren需要在生成vnode之后收集。同时区块本身又是一个嵌套的结构，跟tag模版解析一样涉及到栈的概念，所以可以用类似tag模版解析的方式处理

3.没有被收集到动态子节点，也没有被设置为区块的元素，不会进行diff对比更新了，那el就不会重新赋值，导致el丢失。怎么处理？？？
本身静态但是子节点动态的节点称为静态容器，静态容器也需要做静态提升，而他的动态子节点用计算函数包裹，在每次渲染时执行生成新的子节点

在实现静态容器静态提升的过程中，又暴露出更大的问题，目前的watchEffect不支持嵌套使用，同一个时间点只能存在一个watchEffect，可是我们的父子组件中都存在watchEffect，并且是嵌套关系。。。。之前没有暴露出来问题，现在才暴露出来的原因是：之前的render函数调用后会一次性收集到所有的响应式依赖，依赖已经收集结束后再watchEffect，currentEffect被置空也不影响了。现在render函数只收集到静态容器节点，动态子节点是渐进式收集的，问题也就出来了
那怎么办？？？


## 代码实现


